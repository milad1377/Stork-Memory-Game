<!DOCTYPE html>
<html lang="en">
<head>

   <link rel="icon" type="image/png" href="tab.png">

<meta charset="UTF-8">
<title>Stork Memory Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
/* ---------------------------------- KEYFRAMES ---------------------------------- */
@keyframes fall {
    0% { transform: translateY(-100%); opacity: 0; }
    100% { transform: translateY(0); opacity: 1; }
}

@keyframes urgentPulse {
    0% { transform: scale(1); color: #fff; text-shadow: 0 0 5px red; }
    50% { transform: scale(1.1); color: #ff4d4d; text-shadow: 0 0 20px red; }
    100% { transform: scale(1); color: #fff; text-shadow: 0 0 5px red; }
}

@keyframes neonPulse {
    0% { box-shadow: 0 0 5px #00ff99, 0 0 10px #00ff99; }
    50% { box-shadow: 0 0 15px #00ff99, 0 0 25px #00ff99; }
    100% { box-shadow: 0 0 5px #00ff99, 0 0 10px #00ff99; }
}

/* ---------------------------------- BASE STYLES ---------------------------------- */
body {
    background: #050510;
    color: #fff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    text-align: center;
    min-height: 100vh;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden; /* Prevent scroll for canvas */
}

/* Background Canvas */
#bgCanvas {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: -1;
}

/* UI Containers */
#hud, #controls, #game-container { display: none; position: relative; z-index: 10; }

#game-container {
    margin: 15px auto;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(6, 1fr); 
    gap: 8px; 
    width: 95vw;
    max-width: 420px; 
    aspect-ratio: 4 / 6;
}

.card {
    width: 100%; height: 100%; border-radius: 8px; cursor: pointer;
    position: relative; overflow: hidden;
    transition: transform 0.3s, box-shadow 0.3s; 
    aspect-ratio: 1 / 1; 
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(5px);
}

.card:active:not(.matched) { transform: scale(0.92); }
.card.matched { opacity: 0; pointer-events: none; transform: scale(1.1); }
.card.new-entry { animation: fall 0.4s ease-out; }

/* Images */
.card img { width: 100%; height: 100%; position: absolute; top: 0; left: 0; object-fit: cover; border-radius: 8px; }
.cover {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: #1a1a2e url('logo.png') center/80% no-repeat;
    background-size: cover; z-index: 2;
    border-radius: 8px;
    transition: opacity 0.2s;
}

/* ---------------------------------- SCREENS ---------------------------------- */
.overlay-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(5, 5, 16, 0.95); z-index: 50;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    text-align: center;
    color: #fff;
    backdrop-filter: blur(10px);
}
.hidden { display: none !important; }

#gameLogo { max-width: 180px; margin-bottom: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,255,153,0.3); }

/* Buttons & Inputs */
button {
    background: linear-gradient(135deg, #00ff99 0%, #00cc88 100%);
    border: none; padding: 14px 28px;
    font-size: 16px; border-radius: 12px;
    cursor: pointer; margin: 10px; font-weight: bold; color: #050510;
    transition: all 0.2s;
    box-shadow: 0 4px 15px rgba(0, 255, 153, 0.3);
    text-transform: uppercase; letter-spacing: 1px;
}
button:active { transform: scale(0.95); }
button:disabled { background: #555; cursor: not-allowed; box-shadow: none; transform: none; color: #888; }
.btn-secondary { background: linear-gradient(135deg, #00bfff 0%, #0088cc 100%); color: white; box-shadow: 0 4px 15px rgba(0, 191, 255, 0.3); }

input[type="text"] {
    padding: 14px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2);
    background: rgba(0,0,0,0.3); color: white;
    font-size: 16px; text-align: center;
    margin-bottom: 15px; width: 240px;
    outline: none;
    transition: border-color 0.3s;
}
input[type="text"]:focus { border-color: #00ff99; }

/* Lobby Panel */
.lobby-panel {
    background: rgba(20, 20, 35, 0.8); padding: 30px;
    border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); 
    width: 90%; max-width: 400px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}
.player-list { list-style: none; padding: 0; margin: 20px 0; text-align: left; max-height: 200px; overflow-y: auto; }
.player-list li {
    background: rgba(255,255,255,0.08); padding: 12px; margin-bottom: 8px;
    border-radius: 8px; display: flex; justify-content: space-between; align-items: center;
}
.is-host { color: #ffd700; font-size: 0.75em; border: 1px solid #ffd700; padding: 2px 6px; border-radius: 4px; }
.copy-box {
    background: #0f0f1a; padding: 12px; border-radius: 8px; 
    font-family: 'Courier New', monospace; font-size: 13px; word-break: break-all;
    cursor: pointer; margin-bottom: 15px; border: 1px solid rgba(255,255,255,0.1);
    color: #00ff99;
}
#lobbyCount { font-size: 0.8em; color: #00ff99; margin-left: 10px; }

/* ---------------------------------- HUD ---------------------------------- */
#hud {
    margin-top: 15px; font-size: 18px; display: flex; 
    justify-content: space-between; width: 90%; max-width: 420px;
    background: rgba(255,255,255,0.05); padding: 10px 20px; border-radius: 12px;
    backdrop-filter: blur(5px); box-sizing: border-box;
}
#controls { margin-top: 5px; display: flex; justify-content: center; }
#helpBtn { padding: 10px 20px; font-size: 14px; animation: neonPulse 2s infinite alternate; }

.timer-low { animation: urgentPulse 1s infinite; font-weight: bold; color: #ff4d4d; }

/* ---------------------------------- RESULTS ---------------------------------- */
#result-screen { background: rgba(5, 5, 10, 0.98); }
#result-screen h2 { color: #00ff99; font-size: 42px; margin-bottom: 25px; text-shadow: 0 0 20px rgba(0,255,153,0.5); }

#multiplayer-results { 
    width: 90%; max-width: 350px; margin-bottom: 20px; 
    background: rgba(255,255,255,0.05); border-radius: 15px; padding: 15px;
    max-height: 250px; overflow-y: auto;
}
.result-row { 
    display: flex; justify-content: space-between; align-items: center;
    padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); 
    font-size: 14px;
}
.result-row:last-child { border-bottom: none; }
.my-score-row { background: rgba(0, 255, 153, 0.15); border-radius: 6px; border: 1px solid rgba(0, 255, 153, 0.3); }

.status-playing { color: #00bfff; font-size: 0.85em; margin-left: 5px; }
.status-done { color: #00ff99; font-size: 0.85em; margin-left: 5px; }
.score-val { font-weight: bold; font-size: 1.1em; color: #fff; }

</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<div id="start-screen" class="overlay-screen">
    <h2>Stork Memory</h2>
    <img id="gameLogo" src="game_logo.png" alt="Logo" onerror="this.style.display='none'">
    
    <div id="loginPanel">
        <input type="text" id="playerNameInput" placeholder="Enter Your Username" maxlength="25">
        <br>
        <button id="soloBtn">Play Solo</button>
        <button id="multiBtn" class="btn-secondary">Create Lobby</button>
    </div>
</div>

<div id="lobby-screen" class="overlay-screen hidden">
    <div class="lobby-panel">
        <h3>Lobby <span id="lobbyCount">(0)</span></h3>
        <p style="color:#aaa; font-size:14px; margin-bottom:5px;">Share Link:</p>
        <div class="copy-box" id="shareLink" onclick="copyLink()">Generating Link...</div>
        
        <ul class="player-list" id="lobbyPlayerList"></ul>
        
        <div id="hostControls" class="hidden">
            <button id="hostStartBtn" style="width:100%">START GAME</button>
        </div>
        <div id="clientStatus" class="hidden">
            <p style="color:#00bfff;">Waiting for host to start...</p>
        </div>
        <button onclick="leaveLobby()" style="background:transparent; border:1px solid #ff4d4d; color:#ff4d4d; font-size:14px; width:100%; box-shadow:none; margin-top:10px;">Cancel / Leave</button>
    </div>
</div>

<div id="hud">
    <div>‚≠ê <span id="score">0</span></div>
    <div>‚è≥ <span id="timer">120</span></div>
</div>

<div id="controls">
    <button id="helpBtn">üì° Scan (<span id="helpUses">3</span>)</button>
</div>

<div id="game-container"></div>

<div id="result-screen" class="overlay-screen hidden">
    <h2>Game Result</h2>
    
    <div id="solo-result-container" class="hidden" style="margin-bottom: 20px;">
        <p style="color:#aaa; margin:0; font-size:16px;"></p>
        <div style="font-size: 60px; font-weight:bold; color:#00ff99; text-shadow: 0 0 30px rgba(0,255,153,0.6);" id="final-solo-score-val">0</div>
        <p style="color:#00bfff; font-size:14px; margin-top:5px;">Excellent Work !</p>
    </div>

    <div id="multiplayer-results" class="hidden">
        <h3 style="margin-top:0; color:#aaa; font-size:16px; text-transform:uppercase;">Leaderboard</h3>
        <div id="mp-results-content"></div>
    </div>
    
    <p id="high-score-display" style="color:#888; font-size:14px;"></p>
    
    <div>
        <button onclick="leaveLobby()">Main Menu</button>
        <button id="shareTwitterBtn" style="background:#1DA1F2; color:white; box-shadow: 0 4px 15px rgba(29, 161, 242, 0.3);">Share Results</button>
    </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
  import { getDatabase, ref, set, push, onValue, update, remove, onDisconnect, get } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyC9UjXGGa6Hp4ZacJpx9fWwnAX6QImh8qU",
    authDomain: "stork-memory-game.firebaseapp.com",
    databaseURL: "https://stork-memory-game-default-rtdb.firebaseio.com",
    projectId: "stork-memory-game",
    storageBucket: "stork-memory-game.firebasestorage.app",
    messagingSenderId: "930919129124",
    appId: "1:930919129124:web:5920a81fc02e4706d9b8b1",
    measurementId: "G-TFMESMJS8P"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  
  window.db = db;
  window.dbRef = ref;
  window.dbSet = set;
  window.dbUpdate = update;
  window.dbRemove = remove;
  window.dbOnValue = onValue;
  window.dbGet = get;
  window.dbOnDisconnect = onDisconnect;
</script>

<script>
/* ---------------------------------- VISUAL EFFECTS (CANVAS STARFIELD) ---------------------------------- */
const canvas = document.getElementById('bgCanvas');
const ctx = canvas.getContext('2d');
let stars = [];

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

class Star {
    constructor() {
        this.reset();
    }
    reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 2;
        this.speed = Math.random() * 0.5 + 0.1;
        this.opacity = Math.random();
        this.fadeDir = 0.01;
    }
    update() {
        this.y -= this.speed;
        if (this.y < 0) this.y = canvas.height;
        
        this.opacity += this.fadeDir;
        if(this.opacity > 1 || this.opacity < 0.2) this.fadeDir = -this.fadeDir;
    }
    draw() {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

function initStars() {
    for(let i=0; i<100; i++) stars.push(new Star());
    animateStars();
}

function animateStars() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    stars.forEach(star => { star.update(); star.draw(); });
    requestAnimationFrame(animateStars);
}
initStars();

/* ---------------------------------- GAME CONFIG ---------------------------------- */
const ROWS = 6;
const COLS = 4;
const TOTAL = ROWS * COLS;
const SCORE_PER_MATCH = 10; 
const REVEAL_ON_CLICK_MS = 300;
const HELP_SHOW_MS = 3000;
const HIGH_SCORE_KEY = 'storkHighScore';

let TIME_LEFT = 120;
const UNIQUE_CARD_COUNT = TOTAL / 2;
let helpUses = 3; 

// Generate Image Paths
const IMAGE_PATHS = [];
for (let i = 1; i <= UNIQUE_CARD_COUNT; i++) {
    IMAGE_PATHS.push(`card${i}.png`);
}

// Game State
let board = [];
let revealed = [];
let lock = false;
let score = 0;
let timer;
let isGameActive = false;

// Multiplayer State
let isMultiplayer = false;
let roomId = null;
let playerId = null;
let playerName = "Player";
let isHost = false;
let joiningInProgress = false;

// URL Params for Invite Link
const urlParams = new URLSearchParams(window.location.search);
if(urlParams.get('room')){
    roomId = urlParams.get('room');
    document.getElementById('soloBtn').style.display = 'none';
    document.getElementById('multiBtn').innerText = 'Join Lobby';
}

// DOM Elements
const timerEl = document.getElementById("timer");
const scoreEl = document.getElementById("score");
const helpBtn = document.getElementById("helpBtn");
const helpUsesEl = document.getElementById("helpUses"); 
const resultScreen = document.getElementById("result-screen");
const highScoreDisplayEl = document.getElementById("high-score-display");
const startScreenEl = document.getElementById("start-screen");
const lobbyScreenEl = document.getElementById("lobby-screen");
const playerNameInput = document.getElementById("playerNameInput");

// ----------------------------
// AUDIO SYSTEM
// ----------------------------
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, type = "sine", duration = 0.1, volume = 0.1) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.type = type;
    oscillator.frequency.value = freq;
    gainNode.gain.value = volume;
    // Envelope
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + duration);
}
function playFlipSound() { playSound(400, "sine", 0.1, 0.1); }
function playMatchSound() { 
    playSound(600, "triangle", 0.1, 0.1); 
    setTimeout(() => playSound(900, "sine", 0.2, 0.1), 100); 
}
function playMismatchSound() { playSound(150, "sawtooth", 0.2, 0.1); }

// ---------------------------------
// GAME LOGIC
// ---------------------------------

function getHighScore() { return parseInt(localStorage.getItem(HIGH_SCORE_KEY) || 0, 10); }

function updateHighScore() {
    const current = getHighScore();
    if (score > current) { localStorage.setItem(HIGH_SCORE_KEY, score); return score; }
    return current;
}

function generateBoard() {
    board = [...IMAGE_PATHS, ...IMAGE_PATHS];
    // Fisher-Yates Shuffle
    for (let i = board.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [board[i], board[j]] = [board[j], board[i]];
    }
}

function createBoardUI(){
    const container = document.getElementById("game-container");
    container.innerHTML = "";
    for(let i=0;i<TOTAL;i++){
        const card = document.createElement("div");
        card.className = "card";
        card.dataset.index = i;
        const img = document.createElement("img");
        img.src = board[i];

        const cover = document.createElement("div");
        cover.className = "cover";

        card.appendChild(img);
        card.appendChild(cover);
        container.appendChild(card);
        card.addEventListener("click", () => handleCardClick(card));
    }
}

function revealCard(card){ card.querySelector(".cover").style.opacity = "0"; setTimeout(()=>{card.querySelector(".cover").style.display="none"},200); }
function hideCard(card){ card.querySelector(".cover").style.display = "block"; setTimeout(()=>{card.querySelector(".cover").style.opacity="1"},10); }
function revealAll(){ document.querySelectorAll(".card").forEach(c => { c.querySelector(".cover").style.display="none"; }); }
function hideAll(){ document.querySelectorAll(".card").forEach(c => { c.querySelector(".cover").style.display="block"; c.querySelector(".cover").style.opacity="1"; }); }

function handleCardClick(card){
    if(lock || !isGameActive) return;
    if(card.querySelector(".cover").style.display === "none" || card.classList.contains("matched")) return;

    revealCard(card);
    playFlipSound();
    revealed.push({ idx: card.dataset.index, card, img: board[card.dataset.index] });

    if(revealed.length === 2){
        lock = true;
        setTimeout(checkMatch, REVEAL_ON_CLICK_MS);
    }
}

function checkMatch(){
    const [a,b] = revealed;
    if(a.img === b.img){
        // MATCH
        score += SCORE_PER_MATCH;
        scoreEl.textContent = score;
        
        // BUG FIX: Only sync if game is active. Prevents overwriting final score.
        if(isMultiplayer && isGameActive) syncScore();

        a.card.classList.add("matched");
        b.card.classList.add("matched");
        playMatchSound();
        
        // Falling Logic
        const colA = parseInt(a.idx) % COLS;
        const colB = parseInt(b.idx) % COLS;
        const matchedIndices = [parseInt(a.idx), parseInt(b.idx)];
        setTimeout(() => {
            shiftColumns(colA, colB, matchedIndices); 
            lock = false; 
        }, 300);
    } else {
        // NO MATCH
        hideCard(a.card);
        hideCard(b.card);
        playMismatchSound();
        lock = false; 
    }
    revealed = [];
}

function shiftColumns(colA, colB, matchedIndices) {
    processSingleColumnShift(colA, matchedIndices);
    if (colA !== colB) processSingleColumnShift(colB, matchedIndices);
}

function processSingleColumnShift(colIndex, matchedIndices) {
    let oldColumn = [];
    for (let row = 0; row < ROWS; row++) {
        const index = row * COLS + colIndex;
        oldColumn.push({ img: board[index], index: index });
    }
    let filteredColumn = oldColumn.filter(item => !matchedIndices.includes(item.index));
    const removedCount = ROWS - filteredColumn.length;
    
    for (let row = 0; row < ROWS; row++) {
        const index = row * COLS + colIndex;
        const cardEl = document.querySelector(`[data-index='${index}']`);

        if (row < removedCount) {
             const newCardImg = IMAGE_PATHS[Math.floor(Math.random() * IMAGE_PATHS.length)];
             board[index] = newCardImg;
             cardEl.querySelector("img").src = newCardImg;
             cardEl.classList.add("new-entry"); 
        } else {
            const newCard = filteredColumn[row - removedCount];
            board[index] = newCard.img;
            cardEl.querySelector("img").src = newCard.img;
            cardEl.classList.remove("new-entry");
        }
        cardEl.classList.remove("matched");
        hideCard(cardEl);
        setTimeout(() => cardEl.classList.remove("new-entry"), 500); 
    }
}

function startTimer(){
    timer = setInterval(()=>{
        TIME_LEFT--;
        timerEl.textContent = TIME_LEFT;
        
        if(TIME_LEFT <= 20) {
            timerEl.classList.add('timer-low');
        } else {
            timerEl.classList.remove('timer-low');
        }

        if(TIME_LEFT<=0) endGame();
    },1000);
}

function endGame() {
    clearInterval(timer);
    isGameActive = false;
    lock = true;
    timerEl.classList.remove('timer-low'); 
    
    // Multiplayer End: Sync FINAL Score and lock it.
    if(isMultiplayer) syncFinish();

    const finalHighScore = updateHighScore();
    
    // LOGIC TO SHOW/HIDE SOLO SCORE vs LEADERBOARD
    if(!isMultiplayer) {
        // SOLO MODE: Show Big Score, Hide Leaderboard
        document.getElementById('solo-result-container').classList.remove('hidden');
        document.getElementById('final-solo-score-val').innerText = score;
        
        document.getElementById('multiplayer-results').classList.add('hidden');
        highScoreDisplayEl.textContent = `High Score: ${finalHighScore}`;
    } else {
        // MULTIPLAYER MODE: Hide Big Score, Show Leaderboard
        document.getElementById('solo-result-container').classList.add('hidden');
        
        document.getElementById('multiplayer-results').classList.remove('hidden');
        highScoreDisplayEl.textContent = "";
    }
    
    resultScreen.classList.remove("hidden");
}

// Help Button
helpBtn.onclick = ()=>{
    if(lock || helpUses <= 0 || !isGameActive) return; 
    lock = true;
    revealAll();
    helpUses--;
    helpUsesEl.textContent = helpUses;
    if (helpUses === 0) {
        helpBtn.disabled = true;
        helpBtn.style.animation = 'none';
        helpBtn.style.opacity = '0.5';
    }
    setTimeout(()=>{ hideAll(); lock=false; }, HELP_SHOW_MS);
}

function startGame() {
    startScreenEl.classList.add("hidden");
    lobbyScreenEl.classList.add("hidden");
    
    document.getElementById("hud").style.display = 'flex'; 
    document.getElementById("controls").style.display = 'flex';
    document.getElementById("game-container").style.display = 'grid'; 
    
    timerEl.classList.remove('timer-low');

    clearInterval(timer);
    TIME_LEFT = 120;
    score = 0;
    lock = false;
    revealed = [];
    helpUses = 3;
    isGameActive = true;
    timerEl.textContent = TIME_LEFT;
    scoreEl.textContent = score;
    helpUsesEl.textContent = helpUses;
    helpBtn.disabled = false;
    helpBtn.style.animation = 'neonPulse 2s infinite alternate';
    helpBtn.style.opacity = '1';
    
    generateBoard();
    createBoardUI();
    
    const imagesLoaded = Array.from(document.images).filter(img => img.src.includes('card')).map(img => new Promise(resolve => {
        if (img.complete) resolve();
        else { img.onload = resolve; img.onerror = resolve; }
    }));
    Promise.all(imagesLoaded).then(() => {
        revealAll();
        setTimeout(()=>{
            hideAll();
            startTimer();
        }, 1000);
    });
}

// ---------------------------------
// MULTIPLAYER LOGIC
// ---------------------------------

function getPlayerName(){
    return playerNameInput.value.trim();
}

async function createLobby(){
    if(joiningInProgress) return;
    
    playerName = getPlayerName();
    if(!playerName) {
        alert("Please enter a username first!");
        playerNameInput.focus();
        return;
    }

    const btn = document.getElementById('multiBtn');
    btn.disabled = true;
    btn.innerText = "Creating...";

    if(!window.db) {
        alert("Connecting to server...");
        btn.disabled = false; 
        btn.innerText = "Create Lobby";
        return; 
    }
    
    joiningInProgress = true;
    
    playerId = 'host_' + Date.now();
    roomId = 'room_' + Math.floor(Math.random()*10000);
    isHost = true;
    isMultiplayer = true;

    await window.dbSet(window.dbRef(window.db, `rooms/${roomId}`), {
        status: 'lobby',
        players: {
            [playerId]: { name: playerName, score: 0, isHost: true, isFinished: false }
        }
    });
    
    showLobbyUI();
    listenToLobby();
    joiningInProgress = false;
}

async function joinLobby(){
    if(joiningInProgress) return;
    
    playerName = getPlayerName();
    if(!playerName) {
        alert("Please enter a username first!");
        playerNameInput.focus();
        return;
    }

    if(!window.db) return alert("Connecting...");
    if(!roomId) return; 

    joiningInProgress = true;
    const btn = document.getElementById('multiBtn');
    btn.innerText = "Joining...";
    btn.disabled = true;

    const roomRef = window.dbRef(window.db, `rooms/${roomId}`);
    const snapshot = await window.dbGet(roomRef);
    if(!snapshot.exists()) {
        alert("Room not found or expired!");
        joiningInProgress = false;
        btn.disabled = false;
        btn.innerText = "Join Lobby";
        return;
    }

    const players = snapshot.val().players || {};
    const nameTaken = Object.values(players).some(p => p.name.toLowerCase() === playerName.toLowerCase());
    
    if(nameTaken){
        alert("This username is already taken in this lobby. Please choose another.");
        joiningInProgress = false;
        btn.disabled = false;
        btn.innerText = "Join Lobby";
        return;
    }

    playerId = 'p_' + Date.now();
    isHost = false;
    isMultiplayer = true;

    await window.dbSet(window.dbRef(window.db, `rooms/${roomId}/players/${playerId}`), {
        name: playerName, score: 0, isHost: false, isFinished: false
    });
    
    showLobbyUI();
    listenToLobby();
    joiningInProgress = false;
}

function showLobbyUI(){
    startScreenEl.classList.add('hidden');
    lobbyScreenEl.classList.remove('hidden');
    document.getElementById('shareLink').innerText = window.location.origin + window.location.pathname + '?room=' + roomId;
    
    if(isHost) document.getElementById('hostControls').classList.remove('hidden');
    else document.getElementById('clientStatus').classList.remove('hidden');
}

function listenToLobby(){
    const roomRef = window.dbRef(window.db, `rooms/${roomId}`);
    
    window.dbOnValue(roomRef, (snapshot) => {
        const data = snapshot.val();
        if(!data) {
             if(isGameActive) return; 
             alert("Room closed."); location.href = window.location.pathname; return;
        }

        const list = document.getElementById('lobbyPlayerList');
        list.innerHTML = '';
        const players = data.players || {};
        const playerArray = Object.values(players);
        
        document.getElementById('lobbyCount').innerText = `(${playerArray.length} Players)`;
        
        playerArray.forEach(p => {
            const li = document.createElement('li');
            li.innerHTML = `<span>${p.name}</span> ${p.isHost ? '<span class="is-host">HOST</span>' : ''}`;
            list.appendChild(li);
        });

        if(data.status === 'playing' && !isGameActive) {
            startGame();
            listenForResults();
        }
    });
}

function listenForResults() {
    const playersRef = window.dbRef(window.db, `rooms/${roomId}/players`);
    window.dbOnValue(playersRef, (snapshot) => {
        const players = snapshot.val();
        if(!players) return;

        const sorted = Object.values(players).sort((a,b) => b.score - a.score);
        
        const mpResults = document.getElementById('mp-results-content');
        mpResults.innerHTML = '';
        
        sorted.forEach((p, index) => {
            let rank = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index+1}`;
            
            // STATUS CHECK LOGIC
            let statusHtml = '';
            if(p.isFinished) {
                statusHtml = '<span class="status-done">‚úÖ (Done)</span>';
            } else {
                statusHtml = '<span class="status-playing">‚è≥ (Playing...)</span>';
            }
            
            const div = document.createElement('div');
            div.className = 'result-row';
            
            // Highlight my score
            if(p.name === playerName) {
                div.classList.add('my-score-row');
            }

            div.innerHTML = `
                <div style="display:flex; align-items:center; gap:5px;">
                    <span>${rank} ${p.name}</span>
                    ${statusHtml}
                </div> 
                <span class="score-val">${p.score}</span>
            `;
            mpResults.appendChild(div);
        });
    });
}

document.getElementById('hostStartBtn').onclick = () => {
    window.dbUpdate(window.dbRef(window.db, `rooms/${roomId}`), { status: 'playing' });
};

// FIX: Prevent score sync if game ended
function syncScore(){
    if(!isGameActive) return; // Prevent overwriting final score
    if(!roomId || !playerId) return;
    window.dbUpdate(window.dbRef(window.db, `rooms/${roomId}/players/${playerId}`), { score: score });
}

function syncFinish(){
    if(!roomId || !playerId) return;
    window.dbUpdate(window.dbRef(window.db, `rooms/${roomId}/players/${playerId}`), { score: score, isFinished: true });
}

window.copyLink = function(){
    const link = document.getElementById('shareLink').innerText;
    navigator.clipboard.writeText(link).then(() => alert("Link copied!"));
}

window.leaveLobby = function(){
    if(isHost && roomId && window.db){
        if(!isGameActive) window.dbRemove(window.dbRef(window.db, `rooms/${roomId}`));
    }
    if(!isHost && roomId && window.db) {
        window.dbRemove(window.dbRef(window.db, `rooms/${roomId}/players/${playerId}`));
    }
    location.href = window.location.pathname;
}

document.getElementById("soloBtn").onclick = () => { isMultiplayer=false; startGame(); };

document.getElementById("multiBtn").onclick = () => {
    if(roomId) joinLobby();
    else createLobby();
};

document.getElementById("shareTwitterBtn").onclick = () => {
    const tweetText = encodeURIComponent(`I scored ${score} in Stork Memory! üöÄ #StorkOracle`);
    window.open(`https://x.com/intent/tweet?text=${tweetText}`, '_blank');
};

</script>
</body>
</html>
